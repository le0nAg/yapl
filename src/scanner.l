%{
#include <stdio.h>
#include <string.h>
#include "ast.h"
#include "parser.tab.h"  /* Generated by Bison */
%}

%option noyywrap
%option yylineno

/* Definitions */
DIGIT       [0-9]
LETTER      [a-zA-Z_]
IDENTIFIER  {LETTER}({LETTER}|{DIGIT})*
INTEGER     {DIGIT}+
FLOAT       {DIGIT}+\.{DIGIT}+([eE][+-]?{DIGIT}+)?
STRING      \"([^\\\"]|\\.)*\"
WHITESPACE  [ \t\r]+
NEWLINE     \n

%%

    /* Comments */
"//".*                  { /* Single-line comment, ignore */ }
"/*"([^*]|\*+[^*/])*\*+"/"  { /* Multi-line comment, ignore */ }

    /* Keywords */
"if"            { return IF; }
"else"          { return ELSE; }
"while"         { return WHILE; }
"for"           { return FOR; }
"fn"            { return FN; }
"return"        { return RETURN; }
"int"           { return INT; }
"float"         { return FLOAT_TYPE; }
"str"           { return STR; }
"bool"          { return BOOL; }
"void"          { return VOID; }
"true"          { yylval.intval = 1; return TRUE; }
"false"         { yylval.intval = 0; return FALSE; }
"break"         { return BREAK; }
"continue"      { return CONTINUE; }
"range"         { return RANGE; }
"matrix"        { return MATRIX; }

    /* Operators - Matrix and Pattern Matching */
"@"             { return MATRIX_MUL; }
"~="            { return PATTERN_MATCH; }

    /* Relational Operators */
"=="            { return EQ; }
"!="            { return NE; }
"<="            { return LE; }
">="            { return GE; }
"<"             { return LT; }
">"             { return GT; }

    /* Logical Operators */
"&&"            { return AND; }
"||"            { return OR; }
"!"             { return NOT; }

    /* Assignment Operators */
"="             { return ASSIGN; }
"+="            { return PLUS_ASSIGN; }
"-="            { return MINUS_ASSIGN; }
"*="            { return MUL_ASSIGN; }
"/="            { return DIV_ASSIGN; }

    /* Arithmetic Operators */
"+"             { return PLUS; }
"-"             { return MINUS; }
"*"             { return MUL; }
"/"             { return DIV; }
"%"             { return MOD; }

    /* Increment/Decrement */
"++"            { return INC; }
"--"            { return DEC; }

    /* Range Operator */
".."            { return RANGE_OP; }



    /* Delimiters */
"("             { return LPAREN; }
")"             { return RPAREN; }
"{"             { return LBRACE; }
"}"             { return RBRACE; }
"["             { return LBRACKET; }
"]"             { return RBRACKET; }
";"             { return SEMICOLON; }
","             { return COMMA; }
":"             { return COLON; }

    /* Literals */
{INTEGER}       { yylval.intval = atoi(yytext); return INT_LITERAL; }
{FLOAT}         { yylval.floatval = atof(yytext); return FLOAT_LITERAL; }
{STRING}        { 
                  /* Remove quotes and handle escape sequences */
                  yylval.strval = strdup(yytext + 1);
                  yylval.strval[strlen(yylval.strval) - 1] = '\0';
                  return STRING_LITERAL; 
                }

    /* Identifiers */
{IDENTIFIER}    { yylval.strval = strdup(yytext); return IDENTIFIER; }

    /* Whitespace */
{WHITESPACE}    { /* Ignore whitespace */ }
{NEWLINE}       { /* Line counting handled by %option yylineno */ }

    /* Unrecognized characters */
.               { 
                  fprintf(stderr, "Error: Unrecognized character '%s' at line %d\n", 
                          yytext, yylineno);
                  return ERROR;
                }

%%

/* Additional C code can go here 
void yyerror(const char *s) {
    fprintf(stderr, "Error at line %d: %s\n", yylineno, s);
}
*/